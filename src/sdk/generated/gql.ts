/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 */
const documents = {
    "mutation CreateWebhooks($input: CreateWebhooksInput!) {\n  createWebhooks(input: $input) {\n    priceWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n      bucketId\n      bucketSortkey\n    }\n    decodedLogWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    decodedCallWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    rawCallTraceWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    tokenPairEventWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    nftEventWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n    }\n    rawTransactionWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n  }\n}": types.CreateWebhooksDocument,
    "query FilterExchanges($filters: ExchangeFilters, $phrase: String, $rankings: [ExchangeRanking], $limit: Int, $offset: Int) {\n  filterExchanges(\n    filters: $filters\n    rankings: $rankings\n    limit: $limit\n    phrase: $phrase\n    offset: $offset\n  ) {\n    results {\n      exchange {\n        address\n        iconUrl\n        name\n        tradeUrl\n      }\n      dailyActiveUsers\n      monthlyActiveUsers\n      txnCount1\n      volumeNBT12\n      volumeUSD24\n    }\n  }\n}": types.FilterExchangesDocument,
    "query FilterPairs($filters: PairFilters, $phrase: String, $pairs: [String], $rankings: [PairRanking], $limit: Int, $offset: Int, $matchTokens: PairFilterMatchTokens) {\n  filterPairs(\n    filters: $filters\n    phrase: $phrase\n    pairs: $pairs\n    rankings: $rankings\n    limit: $limit\n    offset: $offset\n    matchTokens: $matchTokens\n  ) {\n    count\n    offset\n    results {\n      createdAt\n      lastTransaction\n      buyCount1\n      buyCount4\n      buyCount12\n      buyCount24\n      highPrice1\n      highPrice4\n      highPrice12\n      highPrice24\n      liquidity\n      liquidityToken\n      quoteToken\n      lowPrice1\n      lowPrice4\n      lowPrice12\n      lowPrice24\n      marketCap\n      price\n      priceScale\n      priceChange1\n      priceChange4\n      priceChange12\n      priceChange24\n      sellCount1\n      sellCount4\n      sellCount12\n      sellCount24\n      txnCount1\n      txnCount4\n      txnCount12\n      txnCount24\n      uniqueBuys1\n      uniqueBuys4\n      uniqueBuys12\n      uniqueBuys24\n      uniqueSells1\n      uniqueSells4\n      uniqueSells12\n      uniqueSells24\n      uniqueTransactions1\n      uniqueTransactions4\n      uniqueTransactions12\n      uniqueTransactions24\n      volumeUSD1\n      volumeUSD4\n      volumeUSD12\n      volumeUSD24\n      pair {\n        token0\n        token1\n        pooled {\n          token0\n          token1\n        }\n      }\n      token0 {\n        address\n        decimals\n        name\n        networkId\n        symbol\n        info {\n          imageSmallUrl\n          circulatingSupply\n          totalSupply\n        }\n      }\n      token1 {\n        address\n        decimals\n        name\n        networkId\n        symbol\n        info {\n          imageSmallUrl\n          circulatingSupply\n          totalSupply\n        }\n      }\n      exchange {\n        address\n        id\n        name\n        exchangeVersion\n        iconUrl\n        networkId\n        tradeUrl\n      }\n    }\n  }\n}": types.FilterPairsDocument,
    "query FilterTokens($filters: TokenFilters, $phrase: String, $tokens: [String], $rankings: [TokenRanking], $limit: Int, $offset: Int) {\n  filterTokens(\n    filters: $filters\n    phrase: $phrase\n    tokens: $tokens\n    rankings: $rankings\n    limit: $limit\n    offset: $offset\n  ) {\n    count\n    page\n    results {\n      buyCount1\n      buyCount4\n      buyCount12\n      buyCount24\n      change1\n      change4\n      change12\n      change24\n      createdAt\n      high1\n      high4\n      high12\n      high24\n      lastTransaction\n      liquidity\n      low1\n      low4\n      low12\n      low24\n      marketCap\n      priceUSD\n      quoteToken\n      sellCount1\n      sellCount4\n      sellCount12\n      sellCount24\n      txnCount1\n      txnCount4\n      txnCount12\n      txnCount24\n      uniqueBuys1\n      uniqueBuys4\n      uniqueBuys12\n      uniqueBuys24\n      uniqueSells1\n      uniqueSells4\n      uniqueSells12\n      uniqueSells24\n      uniqueTransactions1\n      uniqueTransactions4\n      uniqueTransactions12\n      uniqueTransactions24\n      volume1\n      volume4\n      volume12\n      volume24\n      pair {\n        token0\n        token1\n        pooled {\n          token0\n          token1\n        }\n      }\n      token {\n        address\n        decimals\n        name\n        networkId\n        symbol\n        info {\n          imageSmallUrl\n          circulatingSupply\n          totalSupply\n        }\n      }\n    }\n  }\n}": types.FilterTokensDocument,
    "query GetBars($symbol: String!, $from: Int!, $to: Int!, $resolution: String!, $currencyCode: String, $quoteToken: QuoteToken) {\n  getBars(\n    symbol: $symbol\n    from: $from\n    to: $to\n    resolution: $resolution\n    currencyCode: $currencyCode\n    quoteToken: $quoteToken\n  ) {\n    o\n    h\n    l\n    c\n    volume\n  }\n}": types.GetBarsDocument,
    "query GetDetailedPairStats($pairAddress: String!, $networkId: Int!, $tokenOfInterest: TokenOfInterest, $timestamp: Int, $durations: [DetailedPairStatsDuration], $bucketCount: Int) {\n  getDetailedPairStats(\n    pairAddress: $pairAddress\n    networkId: $networkId\n    tokenOfInterest: $tokenOfInterest\n    timestamp: $timestamp\n    durations: $durations\n    bucketCount: $bucketCount\n  ) {\n    pairAddress\n    networkId\n    tokenOfInterest\n    lastTransaction\n    pair {\n      address\n      exchangeHash\n      fee\n      id\n      networkId\n      tickSpacing\n      token0\n      token1\n      createdAt\n      token0Data {\n        address\n        cmcId\n        decimals\n        id\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        socialLinks {\n          bitcointalk\n          blog\n          coingecko\n          coinmarketcap\n          discord\n          email\n          facebook\n          github\n          instagram\n          linkedin\n          reddit\n          slack\n          telegram\n          twitch\n          twitter\n          website\n          wechat\n          whitepaper\n          youtube\n        }\n        info {\n          id\n          address\n          circulatingSupply\n          cmcId\n          isScam\n          name\n          networkId\n          symbol\n          totalSupply\n          imageThumbUrl\n          imageSmallUrl\n          imageLargeUrl\n        }\n        explorerData {\n          id\n          blueCheckmark\n          description\n          divisor\n          tokenPriceUSD\n          tokenType\n        }\n        exchanges {\n          address\n          color\n          id\n          name\n          exchangeVersion\n          iconUrl\n          networkId\n          tradeUrl\n        }\n      }\n      token1Data {\n        address\n        cmcId\n        decimals\n        id\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        socialLinks {\n          bitcointalk\n          blog\n          coingecko\n          coinmarketcap\n          discord\n          email\n          facebook\n          github\n          instagram\n          linkedin\n          reddit\n          slack\n          telegram\n          twitch\n          twitter\n          website\n          wechat\n          whitepaper\n          youtube\n        }\n        info {\n          id\n          address\n          circulatingSupply\n          cmcId\n          isScam\n          name\n          networkId\n          symbol\n          totalSupply\n          imageThumbUrl\n          imageSmallUrl\n          imageLargeUrl\n        }\n        explorerData {\n          id\n          blueCheckmark\n          description\n          divisor\n          tokenPriceUSD\n          tokenType\n        }\n        exchanges {\n          address\n          color\n          id\n          name\n          exchangeVersion\n          iconUrl\n          networkId\n          tradeUrl\n        }\n      }\n      pooled {\n        token0\n        token1\n      }\n    }\n    stats_day1 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_day30 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_hour1 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_hour12 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_hour4 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_min15 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_min5 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_week1 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n  }\n}": types.GetDetailedPairStatsDocument,
    "query GetNetworkStatus($networkIds: [Int!]!) {\n  getNetworkStatus(networkIds: $networkIds) {\n    networkName\n    lastProcessedBlock\n    lastProcessedTimestamp\n  }\n}": types.GetNetworkStatusDocument,
    "query GetNetworks {\n  getNetworks {\n    id\n    name\n  }\n}": types.GetNetworksDocument,
    "query PairEvents($query: EventsQueryInput!) {\n  pairEvents: getTokenEvents(query: $query) {\n    cursor\n    items {\n      address\n      baseTokenPrice\n      blockHash\n      blockNumber\n      eventDisplayType\n      eventType\n      id\n      liquidityToken\n      maker\n      networkId\n      quoteToken\n      token0PoolValueUsd\n      token0SwapValueUsd\n      timestamp\n      token0ValueBase\n      token1PoolValueUsd\n      token1SwapValueUsd\n      token1ValueBase\n      transactionHash\n      transactionIndex\n      logIndex\n    }\n  }\n}": types.PairEventsDocument,
    "query GetTokenPrice($inputs: [GetPriceInput]) {\n  getTokenPrices(inputs: $inputs) {\n    address\n    networkId\n    priceUsd\n  }\n}": types.GetTokenPriceDocument,
    "query GetSparklines($input: TokenSparklineInput!) {\n  tokenSparklines(input: $input) {\n    attribute\n    id\n    sparkline {\n      timestamp\n      value\n    }\n  }\n}": types.GetSparklinesDocument,
    "query GetSymbol($symbol: String!, $currencyCode: String) {\n  getSymbol(symbol: $symbol, currencyCode: $currencyCode) {\n    name\n    description\n    currency_code\n    supported_resolutions\n    pricescale\n    ticker\n    original_currency_code\n  }\n}": types.GetSymbolDocument,
    "query GetTokens($input: [TokenInput!]) {\n  tokens(ids: $input) {\n    address\n    decimals\n    id\n    name\n    networkId\n    symbol\n    totalSupply\n  }\n}": types.GetTokensDocument,
    "query GetWebhooks($cursor: String, $webhookId: String, $bucketId: String, $bucketSortkey: String, $limit: Int) {\n  getWebhooks(\n    cursor: $cursor\n    webhookId: $webhookId\n    bucketId: $bucketId\n    bucketSortkey: $bucketSortkey\n    limit: $limit\n  ) {\n    cursor\n    items {\n      alertRecurrence\n      bucketId\n      bucketSortkey\n      callbackUrl\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEvent: tokenAddress {\n            eq\n          }\n          networkIdPriceEvent: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          output\n          inputJSON: input\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n    }\n  }\n}": types.GetWebhooksDocument,
    "query ListPairsForToken($networkId: Int!, $tokenAddress: String!, $limit: Int) {\n  listPairsForToken(\n    networkId: $networkId\n    tokenAddress: $tokenAddress\n    limit: $limit\n  ) {\n    address\n    exchangeHash\n    fee\n    id\n    networkId\n    tickSpacing\n    pooled {\n      token0\n      token1\n    }\n    token0\n    token1\n    createdAt\n    token0Data {\n      address\n      cmcId\n      decimals\n      id\n      isScam\n      name\n      networkId\n      symbol\n      exchanges {\n        address\n        color\n        id\n        name\n        exchangeVersion\n        iconUrl\n        networkId\n        tradeUrl\n      }\n      info {\n        id\n        address\n        circulatingSupply\n        cmcId\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        imageThumbUrl\n        imageSmallUrl\n        imageLargeUrl\n      }\n      explorerData {\n        id\n        blueCheckmark\n        description\n        divisor\n        tokenPriceUSD\n        tokenType\n      }\n    }\n    token1Data {\n      address\n      cmcId\n      decimals\n      id\n      isScam\n      name\n      networkId\n      symbol\n      exchanges {\n        address\n        color\n        id\n        name\n        exchangeVersion\n        iconUrl\n        networkId\n        tradeUrl\n      }\n      info {\n        id\n        address\n        circulatingSupply\n        cmcId\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        imageThumbUrl\n        imageSmallUrl\n        imageLargeUrl\n      }\n      explorerData {\n        id\n        blueCheckmark\n        description\n        divisor\n        tokenPriceUSD\n        tokenType\n      }\n    }\n  }\n}": types.ListPairsForTokenDocument,
    "query ListTopTokens($limit: Int, $networkFilter: [Int!], $resolution: String) {\n  listTopTokens(\n    limit: $limit\n    networkFilter: $networkFilter\n    resolution: $resolution\n  ) {\n    address\n    decimals\n    exchanges {\n      address\n      id\n      name\n      iconUrl\n      networkId\n      tradeUrl\n    }\n    id\n    liquidity\n    name\n    networkId\n    price\n    resolution\n    symbol\n    topPairId\n    volume\n    uniqueBuys24\n    uniqueSells24\n    txnCount24\n    priceChange24\n  }\n}": types.ListTopTokensDocument,
    "subscription OnBarsUpdated($pairId: String, $quoteToken: QuoteToken) {\n  onBarsUpdated(pairId: $pairId, quoteToken: $quoteToken) {\n    eventSortKey\n    networkId\n    pairAddress\n    pairId\n    timestamp\n    quoteToken\n    aggregates {\n      r1 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r5 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r15 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r30 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r60 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r240 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r720 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r1D {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r7D {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n    }\n  }\n}": types.OnBarsUpdatedDocument,
    "subscription OnEventsCreated($id: String) {\n  onEventsCreated(id: $id) {\n    events {\n      address\n      baseTokenPrice\n      blockHash\n      blockNumber\n      eventDisplayType\n      eventType\n      logIndex\n      id\n      liquidityToken\n      maker\n      networkId\n      timestamp\n      token0SwapValueUsd\n      token0ValueBase\n      token1SwapValueUsd\n      token1ValueBase\n      transactionHash\n      transactionIndex\n      data {\n        ... on MintEventData {\n          amount0\n          amount1\n          amount0Shifted\n          amount1Shifted\n          tickLower\n          tickUpper\n          type\n        }\n        ... on BurnEventData {\n          amount0\n          amount1\n          amount0Shifted\n          amount1Shifted\n          tickLower\n          tickUpper\n          type\n        }\n        ... on SwapEventData {\n          amount0\n          amount0In\n          amount0Out\n          amount1\n          amount1In\n          amount1Out\n          amountNonLiquidityToken\n          priceBaseToken\n          priceBaseTokenTotal\n          priceUsd\n          priceUsdTotal\n          tick\n          type\n        }\n      }\n    }\n    address\n    id\n    networkId\n  }\n}": types.OnEventsCreatedDocument,
    "subscription OnPriceUpdated($address: String, $networkId: Int) {\n  onPriceUpdated(address: $address, networkId: $networkId) {\n    address\n    networkId\n    priceUsd\n  }\n}": types.OnPriceUpdatedDocument,
};

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = graphql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function graphql(source: string): unknown;

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "mutation CreateWebhooks($input: CreateWebhooksInput!) {\n  createWebhooks(input: $input) {\n    priceWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n      bucketId\n      bucketSortkey\n    }\n    decodedLogWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    decodedCallWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    rawCallTraceWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    tokenPairEventWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    nftEventWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n    }\n    rawTransactionWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n  }\n}"): (typeof documents)["mutation CreateWebhooks($input: CreateWebhooksInput!) {\n  createWebhooks(input: $input) {\n    priceWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n      bucketId\n      bucketSortkey\n    }\n    decodedLogWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    decodedCallWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    rawCallTraceWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    tokenPairEventWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n    nftEventWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n    }\n    rawTransactionWebhooks {\n      id\n      webhookType\n      name\n      created\n      alertRecurrence\n      callbackUrl\n      status\n      groupId\n      bucketId\n      bucketSortkey\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEventWebhookCondition: tokenAddress {\n            eq\n          }\n          networkIdPriceEventWebhookCondition: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          inputDecodedCallWebhookCondition: input\n          output\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n      retrySettings {\n        maxTimeElapsed\n        minRetryDelay\n        maxRetryDelay\n        maxRetries\n      }\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query FilterExchanges($filters: ExchangeFilters, $phrase: String, $rankings: [ExchangeRanking], $limit: Int, $offset: Int) {\n  filterExchanges(\n    filters: $filters\n    rankings: $rankings\n    limit: $limit\n    phrase: $phrase\n    offset: $offset\n  ) {\n    results {\n      exchange {\n        address\n        iconUrl\n        name\n        tradeUrl\n      }\n      dailyActiveUsers\n      monthlyActiveUsers\n      txnCount1\n      volumeNBT12\n      volumeUSD24\n    }\n  }\n}"): (typeof documents)["query FilterExchanges($filters: ExchangeFilters, $phrase: String, $rankings: [ExchangeRanking], $limit: Int, $offset: Int) {\n  filterExchanges(\n    filters: $filters\n    rankings: $rankings\n    limit: $limit\n    phrase: $phrase\n    offset: $offset\n  ) {\n    results {\n      exchange {\n        address\n        iconUrl\n        name\n        tradeUrl\n      }\n      dailyActiveUsers\n      monthlyActiveUsers\n      txnCount1\n      volumeNBT12\n      volumeUSD24\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query FilterPairs($filters: PairFilters, $phrase: String, $pairs: [String], $rankings: [PairRanking], $limit: Int, $offset: Int, $matchTokens: PairFilterMatchTokens) {\n  filterPairs(\n    filters: $filters\n    phrase: $phrase\n    pairs: $pairs\n    rankings: $rankings\n    limit: $limit\n    offset: $offset\n    matchTokens: $matchTokens\n  ) {\n    count\n    offset\n    results {\n      createdAt\n      lastTransaction\n      buyCount1\n      buyCount4\n      buyCount12\n      buyCount24\n      highPrice1\n      highPrice4\n      highPrice12\n      highPrice24\n      liquidity\n      liquidityToken\n      quoteToken\n      lowPrice1\n      lowPrice4\n      lowPrice12\n      lowPrice24\n      marketCap\n      price\n      priceScale\n      priceChange1\n      priceChange4\n      priceChange12\n      priceChange24\n      sellCount1\n      sellCount4\n      sellCount12\n      sellCount24\n      txnCount1\n      txnCount4\n      txnCount12\n      txnCount24\n      uniqueBuys1\n      uniqueBuys4\n      uniqueBuys12\n      uniqueBuys24\n      uniqueSells1\n      uniqueSells4\n      uniqueSells12\n      uniqueSells24\n      uniqueTransactions1\n      uniqueTransactions4\n      uniqueTransactions12\n      uniqueTransactions24\n      volumeUSD1\n      volumeUSD4\n      volumeUSD12\n      volumeUSD24\n      pair {\n        token0\n        token1\n        pooled {\n          token0\n          token1\n        }\n      }\n      token0 {\n        address\n        decimals\n        name\n        networkId\n        symbol\n        info {\n          imageSmallUrl\n          circulatingSupply\n          totalSupply\n        }\n      }\n      token1 {\n        address\n        decimals\n        name\n        networkId\n        symbol\n        info {\n          imageSmallUrl\n          circulatingSupply\n          totalSupply\n        }\n      }\n      exchange {\n        address\n        id\n        name\n        exchangeVersion\n        iconUrl\n        networkId\n        tradeUrl\n      }\n    }\n  }\n}"): (typeof documents)["query FilterPairs($filters: PairFilters, $phrase: String, $pairs: [String], $rankings: [PairRanking], $limit: Int, $offset: Int, $matchTokens: PairFilterMatchTokens) {\n  filterPairs(\n    filters: $filters\n    phrase: $phrase\n    pairs: $pairs\n    rankings: $rankings\n    limit: $limit\n    offset: $offset\n    matchTokens: $matchTokens\n  ) {\n    count\n    offset\n    results {\n      createdAt\n      lastTransaction\n      buyCount1\n      buyCount4\n      buyCount12\n      buyCount24\n      highPrice1\n      highPrice4\n      highPrice12\n      highPrice24\n      liquidity\n      liquidityToken\n      quoteToken\n      lowPrice1\n      lowPrice4\n      lowPrice12\n      lowPrice24\n      marketCap\n      price\n      priceScale\n      priceChange1\n      priceChange4\n      priceChange12\n      priceChange24\n      sellCount1\n      sellCount4\n      sellCount12\n      sellCount24\n      txnCount1\n      txnCount4\n      txnCount12\n      txnCount24\n      uniqueBuys1\n      uniqueBuys4\n      uniqueBuys12\n      uniqueBuys24\n      uniqueSells1\n      uniqueSells4\n      uniqueSells12\n      uniqueSells24\n      uniqueTransactions1\n      uniqueTransactions4\n      uniqueTransactions12\n      uniqueTransactions24\n      volumeUSD1\n      volumeUSD4\n      volumeUSD12\n      volumeUSD24\n      pair {\n        token0\n        token1\n        pooled {\n          token0\n          token1\n        }\n      }\n      token0 {\n        address\n        decimals\n        name\n        networkId\n        symbol\n        info {\n          imageSmallUrl\n          circulatingSupply\n          totalSupply\n        }\n      }\n      token1 {\n        address\n        decimals\n        name\n        networkId\n        symbol\n        info {\n          imageSmallUrl\n          circulatingSupply\n          totalSupply\n        }\n      }\n      exchange {\n        address\n        id\n        name\n        exchangeVersion\n        iconUrl\n        networkId\n        tradeUrl\n      }\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query FilterTokens($filters: TokenFilters, $phrase: String, $tokens: [String], $rankings: [TokenRanking], $limit: Int, $offset: Int) {\n  filterTokens(\n    filters: $filters\n    phrase: $phrase\n    tokens: $tokens\n    rankings: $rankings\n    limit: $limit\n    offset: $offset\n  ) {\n    count\n    page\n    results {\n      buyCount1\n      buyCount4\n      buyCount12\n      buyCount24\n      change1\n      change4\n      change12\n      change24\n      createdAt\n      high1\n      high4\n      high12\n      high24\n      lastTransaction\n      liquidity\n      low1\n      low4\n      low12\n      low24\n      marketCap\n      priceUSD\n      quoteToken\n      sellCount1\n      sellCount4\n      sellCount12\n      sellCount24\n      txnCount1\n      txnCount4\n      txnCount12\n      txnCount24\n      uniqueBuys1\n      uniqueBuys4\n      uniqueBuys12\n      uniqueBuys24\n      uniqueSells1\n      uniqueSells4\n      uniqueSells12\n      uniqueSells24\n      uniqueTransactions1\n      uniqueTransactions4\n      uniqueTransactions12\n      uniqueTransactions24\n      volume1\n      volume4\n      volume12\n      volume24\n      pair {\n        token0\n        token1\n        pooled {\n          token0\n          token1\n        }\n      }\n      token {\n        address\n        decimals\n        name\n        networkId\n        symbol\n        info {\n          imageSmallUrl\n          circulatingSupply\n          totalSupply\n        }\n      }\n    }\n  }\n}"): (typeof documents)["query FilterTokens($filters: TokenFilters, $phrase: String, $tokens: [String], $rankings: [TokenRanking], $limit: Int, $offset: Int) {\n  filterTokens(\n    filters: $filters\n    phrase: $phrase\n    tokens: $tokens\n    rankings: $rankings\n    limit: $limit\n    offset: $offset\n  ) {\n    count\n    page\n    results {\n      buyCount1\n      buyCount4\n      buyCount12\n      buyCount24\n      change1\n      change4\n      change12\n      change24\n      createdAt\n      high1\n      high4\n      high12\n      high24\n      lastTransaction\n      liquidity\n      low1\n      low4\n      low12\n      low24\n      marketCap\n      priceUSD\n      quoteToken\n      sellCount1\n      sellCount4\n      sellCount12\n      sellCount24\n      txnCount1\n      txnCount4\n      txnCount12\n      txnCount24\n      uniqueBuys1\n      uniqueBuys4\n      uniqueBuys12\n      uniqueBuys24\n      uniqueSells1\n      uniqueSells4\n      uniqueSells12\n      uniqueSells24\n      uniqueTransactions1\n      uniqueTransactions4\n      uniqueTransactions12\n      uniqueTransactions24\n      volume1\n      volume4\n      volume12\n      volume24\n      pair {\n        token0\n        token1\n        pooled {\n          token0\n          token1\n        }\n      }\n      token {\n        address\n        decimals\n        name\n        networkId\n        symbol\n        info {\n          imageSmallUrl\n          circulatingSupply\n          totalSupply\n        }\n      }\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetBars($symbol: String!, $from: Int!, $to: Int!, $resolution: String!, $currencyCode: String, $quoteToken: QuoteToken) {\n  getBars(\n    symbol: $symbol\n    from: $from\n    to: $to\n    resolution: $resolution\n    currencyCode: $currencyCode\n    quoteToken: $quoteToken\n  ) {\n    o\n    h\n    l\n    c\n    volume\n  }\n}"): (typeof documents)["query GetBars($symbol: String!, $from: Int!, $to: Int!, $resolution: String!, $currencyCode: String, $quoteToken: QuoteToken) {\n  getBars(\n    symbol: $symbol\n    from: $from\n    to: $to\n    resolution: $resolution\n    currencyCode: $currencyCode\n    quoteToken: $quoteToken\n  ) {\n    o\n    h\n    l\n    c\n    volume\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetDetailedPairStats($pairAddress: String!, $networkId: Int!, $tokenOfInterest: TokenOfInterest, $timestamp: Int, $durations: [DetailedPairStatsDuration], $bucketCount: Int) {\n  getDetailedPairStats(\n    pairAddress: $pairAddress\n    networkId: $networkId\n    tokenOfInterest: $tokenOfInterest\n    timestamp: $timestamp\n    durations: $durations\n    bucketCount: $bucketCount\n  ) {\n    pairAddress\n    networkId\n    tokenOfInterest\n    lastTransaction\n    pair {\n      address\n      exchangeHash\n      fee\n      id\n      networkId\n      tickSpacing\n      token0\n      token1\n      createdAt\n      token0Data {\n        address\n        cmcId\n        decimals\n        id\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        socialLinks {\n          bitcointalk\n          blog\n          coingecko\n          coinmarketcap\n          discord\n          email\n          facebook\n          github\n          instagram\n          linkedin\n          reddit\n          slack\n          telegram\n          twitch\n          twitter\n          website\n          wechat\n          whitepaper\n          youtube\n        }\n        info {\n          id\n          address\n          circulatingSupply\n          cmcId\n          isScam\n          name\n          networkId\n          symbol\n          totalSupply\n          imageThumbUrl\n          imageSmallUrl\n          imageLargeUrl\n        }\n        explorerData {\n          id\n          blueCheckmark\n          description\n          divisor\n          tokenPriceUSD\n          tokenType\n        }\n        exchanges {\n          address\n          color\n          id\n          name\n          exchangeVersion\n          iconUrl\n          networkId\n          tradeUrl\n        }\n      }\n      token1Data {\n        address\n        cmcId\n        decimals\n        id\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        socialLinks {\n          bitcointalk\n          blog\n          coingecko\n          coinmarketcap\n          discord\n          email\n          facebook\n          github\n          instagram\n          linkedin\n          reddit\n          slack\n          telegram\n          twitch\n          twitter\n          website\n          wechat\n          whitepaper\n          youtube\n        }\n        info {\n          id\n          address\n          circulatingSupply\n          cmcId\n          isScam\n          name\n          networkId\n          symbol\n          totalSupply\n          imageThumbUrl\n          imageSmallUrl\n          imageLargeUrl\n        }\n        explorerData {\n          id\n          blueCheckmark\n          description\n          divisor\n          tokenPriceUSD\n          tokenType\n        }\n        exchanges {\n          address\n          color\n          id\n          name\n          exchangeVersion\n          iconUrl\n          networkId\n          tradeUrl\n        }\n      }\n      pooled {\n        token0\n        token1\n      }\n    }\n    stats_day1 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_day30 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_hour1 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_hour12 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_hour4 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_min15 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_min5 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_week1 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n  }\n}"): (typeof documents)["query GetDetailedPairStats($pairAddress: String!, $networkId: Int!, $tokenOfInterest: TokenOfInterest, $timestamp: Int, $durations: [DetailedPairStatsDuration], $bucketCount: Int) {\n  getDetailedPairStats(\n    pairAddress: $pairAddress\n    networkId: $networkId\n    tokenOfInterest: $tokenOfInterest\n    timestamp: $timestamp\n    durations: $durations\n    bucketCount: $bucketCount\n  ) {\n    pairAddress\n    networkId\n    tokenOfInterest\n    lastTransaction\n    pair {\n      address\n      exchangeHash\n      fee\n      id\n      networkId\n      tickSpacing\n      token0\n      token1\n      createdAt\n      token0Data {\n        address\n        cmcId\n        decimals\n        id\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        socialLinks {\n          bitcointalk\n          blog\n          coingecko\n          coinmarketcap\n          discord\n          email\n          facebook\n          github\n          instagram\n          linkedin\n          reddit\n          slack\n          telegram\n          twitch\n          twitter\n          website\n          wechat\n          whitepaper\n          youtube\n        }\n        info {\n          id\n          address\n          circulatingSupply\n          cmcId\n          isScam\n          name\n          networkId\n          symbol\n          totalSupply\n          imageThumbUrl\n          imageSmallUrl\n          imageLargeUrl\n        }\n        explorerData {\n          id\n          blueCheckmark\n          description\n          divisor\n          tokenPriceUSD\n          tokenType\n        }\n        exchanges {\n          address\n          color\n          id\n          name\n          exchangeVersion\n          iconUrl\n          networkId\n          tradeUrl\n        }\n      }\n      token1Data {\n        address\n        cmcId\n        decimals\n        id\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        socialLinks {\n          bitcointalk\n          blog\n          coingecko\n          coinmarketcap\n          discord\n          email\n          facebook\n          github\n          instagram\n          linkedin\n          reddit\n          slack\n          telegram\n          twitch\n          twitter\n          website\n          wechat\n          whitepaper\n          youtube\n        }\n        info {\n          id\n          address\n          circulatingSupply\n          cmcId\n          isScam\n          name\n          networkId\n          symbol\n          totalSupply\n          imageThumbUrl\n          imageSmallUrl\n          imageLargeUrl\n        }\n        explorerData {\n          id\n          blueCheckmark\n          description\n          divisor\n          tokenPriceUSD\n          tokenType\n        }\n        exchanges {\n          address\n          color\n          id\n          name\n          exchangeVersion\n          iconUrl\n          networkId\n          tradeUrl\n        }\n      }\n      pooled {\n        token0\n        token1\n      }\n    }\n    stats_day1 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_day30 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_hour1 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_hour12 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_hour4 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_min15 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_min5 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n    stats_week1 {\n      duration\n      start\n      end\n      timestamps {\n        start\n        end\n      }\n      statsUsd {\n        volume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellVolume {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        open {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        highest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        lowest {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        close {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        liquidity {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n      statsNonCurrency {\n        transactions {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buys {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sells {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        traders {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        buyers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n        sellers {\n          change\n          currentValue\n          previousValue\n          buckets\n        }\n      }\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetNetworkStatus($networkIds: [Int!]!) {\n  getNetworkStatus(networkIds: $networkIds) {\n    networkName\n    lastProcessedBlock\n    lastProcessedTimestamp\n  }\n}"): (typeof documents)["query GetNetworkStatus($networkIds: [Int!]!) {\n  getNetworkStatus(networkIds: $networkIds) {\n    networkName\n    lastProcessedBlock\n    lastProcessedTimestamp\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetNetworks {\n  getNetworks {\n    id\n    name\n  }\n}"): (typeof documents)["query GetNetworks {\n  getNetworks {\n    id\n    name\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query PairEvents($query: EventsQueryInput!) {\n  pairEvents: getTokenEvents(query: $query) {\n    cursor\n    items {\n      address\n      baseTokenPrice\n      blockHash\n      blockNumber\n      eventDisplayType\n      eventType\n      id\n      liquidityToken\n      maker\n      networkId\n      quoteToken\n      token0PoolValueUsd\n      token0SwapValueUsd\n      timestamp\n      token0ValueBase\n      token1PoolValueUsd\n      token1SwapValueUsd\n      token1ValueBase\n      transactionHash\n      transactionIndex\n      logIndex\n    }\n  }\n}"): (typeof documents)["query PairEvents($query: EventsQueryInput!) {\n  pairEvents: getTokenEvents(query: $query) {\n    cursor\n    items {\n      address\n      baseTokenPrice\n      blockHash\n      blockNumber\n      eventDisplayType\n      eventType\n      id\n      liquidityToken\n      maker\n      networkId\n      quoteToken\n      token0PoolValueUsd\n      token0SwapValueUsd\n      timestamp\n      token0ValueBase\n      token1PoolValueUsd\n      token1SwapValueUsd\n      token1ValueBase\n      transactionHash\n      transactionIndex\n      logIndex\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetTokenPrice($inputs: [GetPriceInput]) {\n  getTokenPrices(inputs: $inputs) {\n    address\n    networkId\n    priceUsd\n  }\n}"): (typeof documents)["query GetTokenPrice($inputs: [GetPriceInput]) {\n  getTokenPrices(inputs: $inputs) {\n    address\n    networkId\n    priceUsd\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetSparklines($input: TokenSparklineInput!) {\n  tokenSparklines(input: $input) {\n    attribute\n    id\n    sparkline {\n      timestamp\n      value\n    }\n  }\n}"): (typeof documents)["query GetSparklines($input: TokenSparklineInput!) {\n  tokenSparklines(input: $input) {\n    attribute\n    id\n    sparkline {\n      timestamp\n      value\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetSymbol($symbol: String!, $currencyCode: String) {\n  getSymbol(symbol: $symbol, currencyCode: $currencyCode) {\n    name\n    description\n    currency_code\n    supported_resolutions\n    pricescale\n    ticker\n    original_currency_code\n  }\n}"): (typeof documents)["query GetSymbol($symbol: String!, $currencyCode: String) {\n  getSymbol(symbol: $symbol, currencyCode: $currencyCode) {\n    name\n    description\n    currency_code\n    supported_resolutions\n    pricescale\n    ticker\n    original_currency_code\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetTokens($input: [TokenInput!]) {\n  tokens(ids: $input) {\n    address\n    decimals\n    id\n    name\n    networkId\n    symbol\n    totalSupply\n  }\n}"): (typeof documents)["query GetTokens($input: [TokenInput!]) {\n  tokens(ids: $input) {\n    address\n    decimals\n    id\n    name\n    networkId\n    symbol\n    totalSupply\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query GetWebhooks($cursor: String, $webhookId: String, $bucketId: String, $bucketSortkey: String, $limit: Int) {\n  getWebhooks(\n    cursor: $cursor\n    webhookId: $webhookId\n    bucketId: $bucketId\n    bucketSortkey: $bucketSortkey\n    limit: $limit\n  ) {\n    cursor\n    items {\n      alertRecurrence\n      bucketId\n      bucketSortkey\n      callbackUrl\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEvent: tokenAddress {\n            eq\n          }\n          networkIdPriceEvent: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          output\n          inputJSON: input\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n    }\n  }\n}"): (typeof documents)["query GetWebhooks($cursor: String, $webhookId: String, $bucketId: String, $bucketSortkey: String, $limit: Int) {\n  getWebhooks(\n    cursor: $cursor\n    webhookId: $webhookId\n    bucketId: $bucketId\n    bucketSortkey: $bucketSortkey\n    limit: $limit\n  ) {\n    cursor\n    items {\n      alertRecurrence\n      bucketId\n      bucketSortkey\n      callbackUrl\n      conditions {\n        ... on PriceEventWebhookCondition {\n          tokenAddressPriceEvent: tokenAddress {\n            eq\n          }\n          networkIdPriceEvent: networkId {\n            eq\n          }\n          priceUsd {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n        }\n        ... on DecodedLogWebhookCondition {\n          decodingId {\n            eq\n          }\n          eventName {\n            eq\n          }\n          address {\n            eq\n          }\n          event\n        }\n        ... on DecodedCallWebhookCondition {\n          decodingId {\n            eq\n          }\n          methodName {\n            eq\n          }\n          address {\n            eq\n          }\n          from {\n            eq\n          }\n          to {\n            eq\n          }\n          methodId {\n            eq\n          }\n          output\n          inputJSON: input\n        }\n        ... on RawCallTraceWebhookCondition {\n          traceType {\n            eq\n          }\n          result {\n            code {\n              contains\n              notContains\n            }\n          }\n          networkId {\n            oneOf\n          }\n        }\n        ... on TokenPairEventWebhookCondition {\n          tokenAddress {\n            eq\n          }\n          networkId {\n            oneOf\n          }\n          swapValue {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          maker {\n            eq\n          }\n          pairAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          eventType {\n            oneOf\n          }\n        }\n        ... on NftEventWebhookCondition {\n          networkId {\n            oneOf\n          }\n          maker {\n            eq\n          }\n          contractAddress {\n            eq\n          }\n          exchangeAddress {\n            eq\n          }\n          tokenId {\n            eq\n          }\n          tokenAddress {\n            eq\n          }\n          individualBaseTokenPrice {\n            gt\n            gte\n            lt\n            lte\n            eq\n          }\n          eventType {\n            eq\n          }\n          fillSource {\n            oneOf\n          }\n        }\n        ... on RawTransactionWebhookCondition {\n          networkId {\n            oneOf\n          }\n          to {\n            eq\n          }\n          from {\n            eq\n          }\n          toOrFrom {\n            eq\n          }\n          input {\n            contains\n            notContains\n          }\n          ignoreTokenPairEvents\n          ignoreNftEvents\n        }\n      }\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query ListPairsForToken($networkId: Int!, $tokenAddress: String!, $limit: Int) {\n  listPairsForToken(\n    networkId: $networkId\n    tokenAddress: $tokenAddress\n    limit: $limit\n  ) {\n    address\n    exchangeHash\n    fee\n    id\n    networkId\n    tickSpacing\n    pooled {\n      token0\n      token1\n    }\n    token0\n    token1\n    createdAt\n    token0Data {\n      address\n      cmcId\n      decimals\n      id\n      isScam\n      name\n      networkId\n      symbol\n      exchanges {\n        address\n        color\n        id\n        name\n        exchangeVersion\n        iconUrl\n        networkId\n        tradeUrl\n      }\n      info {\n        id\n        address\n        circulatingSupply\n        cmcId\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        imageThumbUrl\n        imageSmallUrl\n        imageLargeUrl\n      }\n      explorerData {\n        id\n        blueCheckmark\n        description\n        divisor\n        tokenPriceUSD\n        tokenType\n      }\n    }\n    token1Data {\n      address\n      cmcId\n      decimals\n      id\n      isScam\n      name\n      networkId\n      symbol\n      exchanges {\n        address\n        color\n        id\n        name\n        exchangeVersion\n        iconUrl\n        networkId\n        tradeUrl\n      }\n      info {\n        id\n        address\n        circulatingSupply\n        cmcId\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        imageThumbUrl\n        imageSmallUrl\n        imageLargeUrl\n      }\n      explorerData {\n        id\n        blueCheckmark\n        description\n        divisor\n        tokenPriceUSD\n        tokenType\n      }\n    }\n  }\n}"): (typeof documents)["query ListPairsForToken($networkId: Int!, $tokenAddress: String!, $limit: Int) {\n  listPairsForToken(\n    networkId: $networkId\n    tokenAddress: $tokenAddress\n    limit: $limit\n  ) {\n    address\n    exchangeHash\n    fee\n    id\n    networkId\n    tickSpacing\n    pooled {\n      token0\n      token1\n    }\n    token0\n    token1\n    createdAt\n    token0Data {\n      address\n      cmcId\n      decimals\n      id\n      isScam\n      name\n      networkId\n      symbol\n      exchanges {\n        address\n        color\n        id\n        name\n        exchangeVersion\n        iconUrl\n        networkId\n        tradeUrl\n      }\n      info {\n        id\n        address\n        circulatingSupply\n        cmcId\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        imageThumbUrl\n        imageSmallUrl\n        imageLargeUrl\n      }\n      explorerData {\n        id\n        blueCheckmark\n        description\n        divisor\n        tokenPriceUSD\n        tokenType\n      }\n    }\n    token1Data {\n      address\n      cmcId\n      decimals\n      id\n      isScam\n      name\n      networkId\n      symbol\n      exchanges {\n        address\n        color\n        id\n        name\n        exchangeVersion\n        iconUrl\n        networkId\n        tradeUrl\n      }\n      info {\n        id\n        address\n        circulatingSupply\n        cmcId\n        isScam\n        name\n        networkId\n        symbol\n        totalSupply\n        imageThumbUrl\n        imageSmallUrl\n        imageLargeUrl\n      }\n      explorerData {\n        id\n        blueCheckmark\n        description\n        divisor\n        tokenPriceUSD\n        tokenType\n      }\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query ListTopTokens($limit: Int, $networkFilter: [Int!], $resolution: String) {\n  listTopTokens(\n    limit: $limit\n    networkFilter: $networkFilter\n    resolution: $resolution\n  ) {\n    address\n    decimals\n    exchanges {\n      address\n      id\n      name\n      iconUrl\n      networkId\n      tradeUrl\n    }\n    id\n    liquidity\n    name\n    networkId\n    price\n    resolution\n    symbol\n    topPairId\n    volume\n    uniqueBuys24\n    uniqueSells24\n    txnCount24\n    priceChange24\n  }\n}"): (typeof documents)["query ListTopTokens($limit: Int, $networkFilter: [Int!], $resolution: String) {\n  listTopTokens(\n    limit: $limit\n    networkFilter: $networkFilter\n    resolution: $resolution\n  ) {\n    address\n    decimals\n    exchanges {\n      address\n      id\n      name\n      iconUrl\n      networkId\n      tradeUrl\n    }\n    id\n    liquidity\n    name\n    networkId\n    price\n    resolution\n    symbol\n    topPairId\n    volume\n    uniqueBuys24\n    uniqueSells24\n    txnCount24\n    priceChange24\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "subscription OnBarsUpdated($pairId: String, $quoteToken: QuoteToken) {\n  onBarsUpdated(pairId: $pairId, quoteToken: $quoteToken) {\n    eventSortKey\n    networkId\n    pairAddress\n    pairId\n    timestamp\n    quoteToken\n    aggregates {\n      r1 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r5 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r15 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r30 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r60 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r240 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r720 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r1D {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r7D {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n    }\n  }\n}"): (typeof documents)["subscription OnBarsUpdated($pairId: String, $quoteToken: QuoteToken) {\n  onBarsUpdated(pairId: $pairId, quoteToken: $quoteToken) {\n    eventSortKey\n    networkId\n    pairAddress\n    pairId\n    timestamp\n    quoteToken\n    aggregates {\n      r1 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r5 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r15 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r30 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r60 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r240 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r720 {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r1D {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n      r7D {\n        t\n        usd {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n        token {\n          t\n          o\n          h\n          l\n          c\n          volume\n        }\n      }\n    }\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "subscription OnEventsCreated($id: String) {\n  onEventsCreated(id: $id) {\n    events {\n      address\n      baseTokenPrice\n      blockHash\n      blockNumber\n      eventDisplayType\n      eventType\n      logIndex\n      id\n      liquidityToken\n      maker\n      networkId\n      timestamp\n      token0SwapValueUsd\n      token0ValueBase\n      token1SwapValueUsd\n      token1ValueBase\n      transactionHash\n      transactionIndex\n      data {\n        ... on MintEventData {\n          amount0\n          amount1\n          amount0Shifted\n          amount1Shifted\n          tickLower\n          tickUpper\n          type\n        }\n        ... on BurnEventData {\n          amount0\n          amount1\n          amount0Shifted\n          amount1Shifted\n          tickLower\n          tickUpper\n          type\n        }\n        ... on SwapEventData {\n          amount0\n          amount0In\n          amount0Out\n          amount1\n          amount1In\n          amount1Out\n          amountNonLiquidityToken\n          priceBaseToken\n          priceBaseTokenTotal\n          priceUsd\n          priceUsdTotal\n          tick\n          type\n        }\n      }\n    }\n    address\n    id\n    networkId\n  }\n}"): (typeof documents)["subscription OnEventsCreated($id: String) {\n  onEventsCreated(id: $id) {\n    events {\n      address\n      baseTokenPrice\n      blockHash\n      blockNumber\n      eventDisplayType\n      eventType\n      logIndex\n      id\n      liquidityToken\n      maker\n      networkId\n      timestamp\n      token0SwapValueUsd\n      token0ValueBase\n      token1SwapValueUsd\n      token1ValueBase\n      transactionHash\n      transactionIndex\n      data {\n        ... on MintEventData {\n          amount0\n          amount1\n          amount0Shifted\n          amount1Shifted\n          tickLower\n          tickUpper\n          type\n        }\n        ... on BurnEventData {\n          amount0\n          amount1\n          amount0Shifted\n          amount1Shifted\n          tickLower\n          tickUpper\n          type\n        }\n        ... on SwapEventData {\n          amount0\n          amount0In\n          amount0Out\n          amount1\n          amount1In\n          amount1Out\n          amountNonLiquidityToken\n          priceBaseToken\n          priceBaseTokenTotal\n          priceUsd\n          priceUsdTotal\n          tick\n          type\n        }\n      }\n    }\n    address\n    id\n    networkId\n  }\n}"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "subscription OnPriceUpdated($address: String, $networkId: Int) {\n  onPriceUpdated(address: $address, networkId: $networkId) {\n    address\n    networkId\n    priceUsd\n  }\n}"): (typeof documents)["subscription OnPriceUpdated($address: String, $networkId: Int) {\n  onPriceUpdated(address: $address, networkId: $networkId) {\n    address\n    networkId\n    priceUsd\n  }\n}"];

export function graphql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;